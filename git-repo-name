#!/usr/bin/env bash

set -e

# ARG_DEFAULTS_POS([])
# ARG_POSITIONAL_SINGLE([command],[Command to execute (fetch, sync, or config)])
# ARG_OPTIONAL_SINGLE([source],[s],[Specify whether remote or local (valid: remote, local).],[remote])
# ARG_OPTIONAL_BOOLEAN([dry-run],[n],[Print commands without executing them],[off])
# ARG_HELP([git-repo-name: sync repository name between remote and local
#
# Commands:
#       fetch               Get the repository name from remote
#       sync                Sync local directory name with remote repository name
#       config              Configure settings:
#          github-token             Get the configured GitHub token
#          github-token <token>     Set the GitHub token for authentication
# ])
# ARG_LEFTOVERS([command_args],[Command arguments])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='snh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_command=
_arg_leftovers=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_source="remote"
_arg_dry_run="off"


print_help()
{
	printf '%s\n' "git-repo-name: sync repository name between remote and local
#
# Commands:
#       fetch               Get the repository name from remote
#       sync                Sync local directory name with remote repository name
#       config              Configure settings:
#          github-token             Get the configured GitHub token
#          github-token <token>     Set the GitHub token for authentication
# "
	printf 'Usage: %s [-s|--source <arg>] [-n|--(no-)dry-run] [-h|--help] <command> ... \n' "$0"
	printf '\t%s\n' "<command>: Command to execute (fetch, sync, or config)"
	printf '\t%s\n' "... : command_args"
	printf '\t%s\n' "-s, --source: Specify whether remote or local (valid: remote, local). (default: 'remote')"
	printf '\t%s\n' "-n, --dry-run, --no-dry-run: Print commands without executing them (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-s|--source)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_source="$2"
				shift
				;;
			--source=*)
				_arg_source="${_key##--source=}"
				;;
			-s*)
				_arg_source="${_key##-s}"
				;;
			-n|--no-dry-run|--dry-run)
				_arg_dry_run="on"
				test "${1:0:5}" = "--no-" && _arg_dry_run="off"
				;;
			-n*)
				_arg_dry_run="on"
				_next="${_key##-n}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-n" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'command'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_command "
	_our_args=$((${#_positionals[@]} - 1))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names="$_positional_names _arg_leftovers[$((ii + 0))]"
	done

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

function get_remote_name() {
  local url="$1"

  # Remove .git suffix if present
  url="${url%.git}"

  # Handle SSH format (git@github.com:user/repo)
  if [[ "$url" =~ ^git@ ]]; then
    url="${url#*:}"  # Remove everything up to and including the colon
  fi

  # Handle HTTPS format (https://github.com/user/repo)
  url="${url##*/}"  # Get last part of path

  echo "$url"
}

function config_set_github_token() {
  local token="$1"
  local config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/git-repo-name"
  local config_file="$config_dir/credentials"

  # Create config directory with secure permissions
  mkdir -p "$config_dir"
  chmod 700 "$config_dir"

  # Create credentials file
  printf "[github]\ntoken = %s\n" "$token" > "$config_file"
  chmod 600 "$config_file"

  echo "GitHub token configured successfully in $config_file"
}

function config_get_github_token() {
  local config_file="${XDG_CONFIG_HOME:-$HOME/.config}/git-repo-name/credentials"

  if [ -f "$config_file" ]; then
    token=$(awk -F ' = ' '/^token/{print $2}' "$config_file")
    if [ -n "$token" ]; then
      echo "$token"
      return 0
    fi
  fi

  echo "No GitHub token found in configuration" >&2
  echo "To set a GitHub token, run: git repo-name config github-token <token>" >&2
  return 1
}

function is_github_url() {
  local url="$1"
  [[ $url =~ ^(https://github\.com/|git@github\.com:|git://github\.com/) ]]
}

function get_github_repo_info() {
  local owner="$1"
  local repo="$2"
  local token
  token=$(config_get_github_token) || return 1

  local api_response
  api_response=$(curl -s -H "Authorization: token $token" \
    "https://api.github.com/repos/$owner/$repo")

  # Check if response contains error
  if [[ "$api_response" =~ "\"message\":\"Not Found\"" ]]; then
    echo "Repository not found: $owner/$repo" >&2
    return 1
  fi

  echo "$api_response"
}

function extract_github_parts() {
  local url="$1"
  local owner_repo

  # Handle different URL formats
  case "$url" in
    "git@github.com:"*)
      owner_repo="${url#git@github.com:}"
      ;;
    "git://github.com/"*)
      owner_repo="${url#git://github.com/}"
      ;;
    "https://github.com/"*)
      owner_repo="${url#https://github.com/}"
      ;;
    *)
      echo "Unsupported GitHub URL format: $url" >&2
      return 1
      ;;
  esac

  # Remove .git suffix if present
  owner_repo="${owner_repo%.git}"
  
  # Split into owner and repo
  local owner="${owner_repo%%/*}"
  local repo="${owner_repo#*/}"
  
  echo "$owner $repo"
}

function sync() {
  local remote_url
  remote_url=$(git remote get-url origin)

  if is_github_url "$remote_url"; then
    # Get current owner and repo from URL
    read -r owner repo <<< "$(extract_github_parts "$remote_url")"
    
    # Get latest repo info from GitHub
    local repo_info
    repo_info=$(get_github_repo_info "$owner" "$repo")
    
    # Extract new clone URL using sed
    local new_url
    new_url=$(echo "$repo_info" | sed -n 's/.*"clone_url": *"\([^"]*\)".*/\1/p')
    
    # Extract remote name using awk
    local remote_name
    remote_name=$(echo "$repo_info" | awk -F'"' '/"name"/{print $4}')
    
    # Update remote URL if changed
    if [ "$new_url" != "$remote_url" ]; then
      echo "Updating remote URL to: $new_url"
      git remote set-url origin "$new_url"
    fi
  else
    local remote_name
    remote_name=$(get_remote_name "$remote_url")
  fi

  local local_name
  local_name=$(basename "$(git rev-parse --show-toplevel)")

  if [ "$remote_name" = "$local_name" ]; then
    echo "Repository names already match: $local_name"
  else
    local parent_dir
    parent_dir="$(dirname "$(git rev-parse --show-toplevel)")"
    echo "Renaming directory from '$local_name' to '$remote_name'"
    mv "$parent_dir/$local_name" "$parent_dir/$remote_name"
  fi
}

function run_config() {
  # Expected usage: git repo-name config github-token TOKEN
  if [ $# -lt 1 ]; then
    echo "No config key provided" >&2
    echo "Usage: git repo-name config <key> [value]" >&2
    exit 1
  fi
  local key="$1"
  shift
  case "$key" in
    github-token)
      if [ $# -eq 0 ]; then
         # Getter
         config_get_github_token
      else
         # Setter
         config_set_github_token "$1"
      fi
      ;;
    *)
      echo "Unknown config key: $key" >&2
      echo "Valid keys: github-token" >&2
      exit 1
      ;;
  esac
}

function run_sync() {
  # Validate the --source option
  if [[ "$_arg_source" != "remote" && "$_arg_source" != "local" ]]; then
    echo "Invalid value for --source: '$_arg_source'. Valid values are 'remote' or 'local'."
    exit 2
  fi
  # Check for dry-run
  if [ "$_arg_dry_run" = "on" ]; then
    echo "Dry run: not executing changes."
    exit 0
  fi
  sync
}

function run_fetch() {
  local remote_url
  remote_url=$(git remote get-url origin)
  local remote_name
  remote_name=$(get_remote_name "$remote_url")
  echo "$remote_name"
}

# --- Command dispatch ---
case "$_arg_command" in
    fetch)
        run_fetch "${_arg_leftovers[@]}"
        ;;
    sync)
        run_sync "${_arg_leftovers[@]}"
        ;;
    config)
        run_config "${_arg_leftovers[@]}"
        ;;
    *)
        echo "Unknown command: $_arg_command" >&2
        exit 1
        ;;
esac
# ] <-- needed because of Argbash
